#!/bin/sh

# Key Geli Tank

. /usr/local/bin/loadmyvars.sh

# 4096 block to futureproof hdd upgrade of zpool
sysctl vfs.zfs.min_auto_ashift=12

TANKPART="4"
align_big="-a 1m"
KGT_DATA_AUTO_SIZE=1
KGT_SECTOR_SIZE=4096
KGT_NEW_POOL_NAME="tank"
KGT_VDEV_TYPE=""
KGT_TMPFS=/tmp/tmpfs
NEWPASSFILE=${KGT_TMPFS}/geli_password.txt
KGT_KEYPKGDIR=/etc/keypkg
KGT_KEYPKGKEY=${KGT_KEYPKGDIR}/key.pem
KGT_KEYPKGPUBCERT=${KGT_KEYPKGDIR}/cert.pem
KGT_KEYSIZE=8192
KGT_KEYTYPE=rsa
keypkg_ssh_config="/etc/keypkg/ssh_config"

usage() {
    cat <<EOF
usage:  ${0##*/} -d disk

        -f keypool  Key pool name.
        -d disk     Disk to use.
        -h          Help.
        -p name     ZFS pool name, must be unique.
        -r          Select ZFS raid mode if multiple -d given.
        -t part     GPT slice that should be used (eg. 5 or 6)
        -z size     ZFS pool size.

EOF
}

exiterror() {
    exitcode=$1
    shift
    if [ "${exitcode}" != "0" ]; then
        echo "ERROR: code ${exitcode}: $@"
    fi
    umount ${FZG_TMP_CRYPT} >/dev/null 2>&1
    umount ${BSDINSTALL_TMPBOOT} >/dev/null 2>&1
    exit ${exitcode}
}

runorerror() {
    $@ || exiterror $? $@
}

mount_tmpfsdir() {
    mkdir -p $KGT_TMPFS
    chmod 700 $KGT_TMPFS
    mount -t tmpfs tmpfs $KGT_TMPFS
    if ! mount | grep 'tmpfs on /tmp/tmpfs (tmpfs' >/dev/null 2>&1 ; then
        exit 1
    fi
    touch $NEWPASSFILE
    chmod 600 $NEWPASSFILE
}

if [ $# -eq 0 ]; then
    usage ; exiterror 1
fi
while getopts t:f:d:p:r:z:h o; do
    case "${o}" in
        t) TANKPART="${OPTARG}" ;;
        f) KGT_KEY_POOL_NAME="${OPTARG}" ;;
        d) KGT_DISKS="${KGT_DISKS} ${OPTARG##/dev/}" ;;
        p) KGT_NEW_POOL_NAME="${OPTARG}" ;;
        r) KGT_VDEV_TYPE="${OPTARG}" ;;
        z) KGT_DATA_SIZES="${OPTARG}" ; unset KGT_DATA_AUTO_SIZE ;;
        h) usage ; exiterror 1 ;;
        [?]) usage ; exiterror 1 ;;
    esac
done

# Check that a pool named "key" exists
if [ "x" = "x$KGT_KEY_POOL_NAME" ]; then
    KGT_KEY_POOL_NAME="key"
fi
if ! zpool list $KGT_KEY_POOL_NAME >/dev/null 2>&1 ; then
    exiterror 1 "Pool $KGT_KEY_POOL_NAME doesn't exist."
fi
ismounted=$( zfs list -H -o mounted $KGT_KEY_POOL_NAME )
if [ "yes" != "$ismounted" ]; then
    exiterror 1 "Pool $KGT_KEY_POOL_NAME is not mounted."
fi

mountdir=$( zfs list -H -o mountpoint $KGT_KEY_POOL_NAME )
ENCPASSFILE=${mountdir}/keypkg_$(hostname -s).smime

# create /etc/keypkg
install -d -m 0700 -o root -g wheel $KGT_KEYPKGDIR
chmod 0700 $KGT_KEYPKGDIR
chown root:wheel $KGT_KEYPKGDIR
# generate key if not exist
if [ ! -e $KGT_KEYPKGPUBCERT ]; then
    echo "Generating a $KGT_KEYSIZE bit $KGT_KEYTYPE private key. Please wait..."
    yes '' | openssl req -x509 -nodes -days 36500 -newkey $KGT_KEYTYPE:$KGT_KEYSIZE \
        -keyout $KGT_KEYPKGKEY -out $KGT_KEYPKGPUBCERT 2>/dev/null
    chmod 400 $KGT_KEYPKGKEY
    chmod 400 $KGT_KEYPKGPUBCERT
fi

if [ ! -e $ENCPASSFILE ]; then
    # Prompt for geli passphrase
    stty -echo
    printf "GELI Encryption Passphrase:"
    read PASSWORD

    # newline
    echo

    # write passphrase to "$KGT_TMPFS/geli_password.txt" to be encrypted
    mount_tmpfsdir
    echo $PASSWORD >$NEWPASSFILE
    if [ ! -e $NEWPASSFILE ]; then
        exiterror 1 "Failed to save passphrase to $NEWPASSFILE."
    fi
    # encrypt $NEWPASSFILE to $ENCPASSFILE
    openssl smime -sign -binary -nodetach -nocerts \
        -signer $KGT_KEYPKGPUBCERT -inkey $KGT_KEYPKGKEY \
        -in $NEWPASSFILE \
            | openssl smime -encrypt -aes-256-cbc $KGT_KEYPKGPUBCERT \
            | openssl smime -sign -binary -nodetach -nocerts \
                -signer $KGT_KEYPKGPUBCERT -inkey $KGT_KEYPKGKEY \
                -out $ENCPASSFILE
    chmod 600 $ENCPASSFILE
    # unmount so we lose "$KGT_TMPFS/geli_password.txt"
    umount -f $KGT_TMPFS
fi

# Verify package was for self
if ! openssl smime -verify -CAfile $KGT_KEYPKGPUBCERT -certfile $KGT_KEYPKGPUBCERT \
        -in $ENCPASSFILE >/dev/null 2>/dev/null ; then
    echo "Verification of $ENCPASSFILE failed."
    exit 1
fi
# Decrypt ENCPASSFILE to KGT_TMPFS to make sure it works
mount_tmpfsdir
openssl smime -verify -CAfile $KGT_KEYPKGPUBCERT -certfile $KGT_KEYPKGPUBCERT \
    -in $ENCPASSFILE 2>/dev/null \
        | openssl smime -decrypt -binary -nointern -recip $KGT_KEYPKGPUBCERT -inkey $KGT_KEYPKGKEY \
        | openssl smime -verify -CAfile $KGT_KEYPKGPUBCERT -certfile $KGT_KEYPKGPUBCERT \
            -out $NEWPASSFILE 2>/dev/null
chmod 600 $NEWPASSFILE

# add data partitions to disks
echo "Creating data partitions ..."
for disk in ${KGT_DISKS}; do
    echo "${disk}"
    PARTCREATED=0
    if [ "${KGT_DATA_AUTO_SIZE}" ]; then
        # estimate using gpart free
        KGT_DATA_TRYSIZE=$( gpart show ${disk} | grep '\- free \-' | tail -1 | awk '{ printf "%.0f\n", $2 / 2097152 }' )
    else
        KGT_DATA_TRYSIZE=${FZG_DATA_SIZES}
    fi
    # only try it 3 times, each time decrement by 1
    for i in 1 2 3 ; do
        if [ ${PARTCREATED} -ne 1 ] && [ ${KGT_DATA_TRYSIZE} -gt 0 ]; then
            ### we try to add in whole integer sizes of GB so that all disk partition sizes are equal
            ### so that we can mirror them correctly without having to worry about MB of variations
            if gpart add -i ${TANKPART} -t freebsd-zfs ${align_big} -s ${KGT_DATA_TRYSIZE}G ${disk} >/dev/null 2>&1 ; then
                echo " success adding a ${KGT_DATA_TRYSIZE}G partition on ${disk}"
                PARTCREATED=1
                runorerror "zpool labelclear -f /dev/${disk}p${TANKPART}"
                GPARTS="${GPARTS} ${disk}p${TANKPART}"
            else
                KGT_DATA_TRYSIZE=$(( KGT_DATA_TRYSIZE - 1 ))
            fi
        fi
    done
    [ ${PARTCREATED} -ne 1 ] && echo " error adding partition on ${disk}."
done
cat >>/etc/rc.conf.d/geli <<EOF
geli_devices="${GPARTS}"
EOF

# geli init all vdevs with passphrase
echo -n "Initializing geli partitions ..."
vdevs=""
for disk in ${GPARTS}; do
    echo -n " ${disk}"
    # init
    runorerror "geli init -e AES-XTS -l 256 -J $NEWPASSFILE -s $KGT_SECTOR_SIZE ${disk}"
    # remove boot flag
    runorerror "geli configure -B ${disk}"
    # attach
    runorerror "geli attach -j $NEWPASSFILE ${disk}"
    # write geli_${provider_}_flags to rc.conf.d/geli
    cat >>/etc/rc.conf.d/geli <<EOF
geli_${disk}_flags="-j $NEWPASSFILE"
EOF
    vdevs="${vdevs} ${disk}.eli"
done

umount -f $KGT_TMPFS

count=$( echo "${vdevs}" | wc -w | awk '{ print $1 }' )
if [ "${count}" -gt "2" -a "${KGT_VDEV_TYPE}" != "mirror" ]; then
    KGT_VDEV_TYPE="mirror"
fi
# create new pool
runorerror "zpool create -O compress=lz4 -O atime=off $KGT_NEW_POOL_NAME $KGT_VDEV_TYPE $vdevs"

# enable keypkg in rc.conf
runorerror "install -C -m 755 /root/git/freebsd-install-script/etc/rc.d/keypkg ${FZG_MNT}/etc/rc.d/keypkg"
runorerror "sysrc -f /etc/rc.conf.d/keypkg keypkg_enable=YES"
runorerror "sysrc -f /etc/rc.conf.d/keypkg keypkg_zpool=$KGT_KEY_POOL_NAME"
runorerror "sysrc -f /etc/rc.conf.d/keypkg keypkg_file=keypkg_$(hostname -s).smime"
cat >>/etc/rc.conf.d/keypkg <<EOF
# keypkg_ssh="one two three"
keypkg_ssh_flags="-i /etc/keypkg/id_rsa -F $keypkg_ssh_config -o UserKnownHostsFile=/etc/keypkg/known_hosts"
EOF
cat >>$keypkg_ssh_config <<EOF
Host one
    Hostname keyserver1
    Port 6371
    User $(hostname -s)
Host two
    Hostname keyserver2
    Port 6371
    User $(hostname -s)
Host three
    Hostname headnode
    Port 6371
    User $(hostname -s)
EOF

echo "Reboot to test."
